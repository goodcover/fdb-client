//| mill-version: 1.1.1
//| mvnDeps:
//| - com.lihaoyi::mill-contrib-scoverage:$MILL_VERSION
//| - com.lihaoyi::mill-contrib-scalapblib:$MILL_VERSION

package build

import coursier.core.{ Attributes, Classifier, Configuration }
import coursier.core.VariantSelector.ConfigurationBased
import mill.*
import mill.api.PathRef
import mill.contrib.scalapblib.*
import mill.contrib.scoverage.*
import mill.javalib.api.JvmWorkerUtil
import mill.javalib.publish.Developer
import mill.scalalib.*
import mill.scalalib.publish.*
import mill.scalalib.scalafmt.*
import mill.util.{ VcsVersion, VcsVersionModule }

// Version definitions
object Versions {
  val autoService        = "1.1.1"
  val betterMonadicFor   = "0.3.1"
  val fdbRecord          = "4.9.6.0"
  val foundationDb       = "7.3.71"
  val lucene             = "8.11.4"
  val logback            = "1.5.27"
  val pekko              = "1.0.3"
  val jsoniterScala      = "2.37.11"
  val kindProjector      = "0.13.4"
  val pprint             = "0.9.0"
  val protobuf           = "3.25.8"
  val rezilience         = "0.10.5"
  // Keep the pull_request.yml up to date
  val scala213           = "2.13.18"
  // Keep the pull_request.yml up to date
  val scala3             = "3.3.7"
  val scalapbSpark       = "1.0.5"
  val scoverage          = "2.5.2"
  val sourcecode         = "0.4.2"
  val spark              = "3.5.8"
  val spark4             = "4.0.1"
  val sparkEncoders      = "0.2.0.2"
  val scalatest          = "3.2.16"
  val zio                = "2.1.19"
  val zioReactiveStreams = "2.0.2"
  val scalapb            = "0.11.15"

  val JavaVersion      = "11"
  val SparkJavaVersion = "17"

  val scalaVersions = Seq(scala213, scala3)

  val sparkMatrix = for {
    crossVersion <- scalaVersions
    sparkVersion <- Seq(Versions.spark, Versions.spark4)
  } yield (crossVersion, sparkVersion)
}

// Common settings trait
trait CommonModule
    extends SbtModule
    with ScalafmtModule
    with ScoverageModule
    with CrossSbtModule
    with PublishModule
    with VcsVersionModule { outer =>

  def JavaVersion: String = Versions.JavaVersion

  def scalacOptions = Task {
    if (outer.scalaVersion() == Versions.scala213) {
      Seq(
        "-Ymacro-annotations",
        "-release",
        JavaVersion,
        "-Ypatmat-exhaust-depth",
        "40",
        "-Xsource:3",
        "-Wconf:src=src_managed/.*:silent",
        "-Wconf:src=org/apache/spark/sql/proto/.*:silent"
      )
    } else {
      Seq(
        "-release",
        JavaVersion,
        "-source:future",
        "-Wconf:src=src_managed/.*:silent",
        "-Wconf:src=org/apache/spark/sql/proto/.*:silent"
      )
    }
  }

  def javacOptions = Seq("-source", Versions.JavaVersion, "-target", Versions.JavaVersion, "-proc:full")

  def scalacPluginMvnDeps = Task {
    if (outer.scalaVersion() == Versions.scala213)
      Seq(
        mvn"org.scala-lang:scala-reflect:${Versions.scala213}",
        mvn"com.olegpy::better-monadic-for:${Versions.betterMonadicFor}",
        mvn"org.typelevel:::kind-projector:${Versions.kindProjector}"
      )
    else Seq.empty
  }

  // Publishing configuration

  def pomSettings = PomSettings(
    description = "FDB Client Library",
    organization = "com.goodcover.fdb",
    url = "https://github.com/goodcover/fdb-client",
    licenses = Seq(License.`Apache-2.0`),
    versionControl = VersionControl.github("goodcover", "fdb-client"),
    developers = Seq(
      Developer( //
        "dispalt",
        "Dan Di Spaltro",
        "https://github.com/dispalt",
        Some("https://github.com/goodcover"),
        Some("https://www.goodcover.com"),
      )
    )
  )

  // Test framework configuration
  def testFramework = "zio.test.sbt.ZTestFramework"

  // Coverage exclusions
  def scoverageExcludedPackages = Seq(
    raw"com\.goodcover\.fdb\.record\.es\.proto\.*",
    raw"org\.apache\.spark\.sql\.proto\.*",
    raw"com\.goodcover\.fdb\.record\.lucene\.proto\.*",
    ".*Test.*",
    ".*javadsl.*"
  )

  def scoverageExcludedFiles = Seq.empty[String]

  private def isScala3: Task[Boolean] = Task.Anon(JvmWorkerUtil.isScala3(outer.scalaVersion()))
  def scoverageVersion                = Versions.scoverage

  override lazy val scoverage = new ScoverageData {
    override def scalacOptions: T[Seq[String]] =
      Task {
        val excludeFilePrefix = if (isScala3()) "-coverage-exclude-files" else "-P:scoverage:excludedFiles"
        val excludePkgsPrefix = if (isScala3()) "-coverage-exclude-classlikes" else "-P:scoverage:excludedPackages"

        val excludePkgs  =
          if (scoverageExcludedPackages.isEmpty) Seq.empty
          else Seq(s"$excludePkgsPrefix:${scoverageExcludedPackages.mkString(";")}")
        val excludeFiles =
          if (scoverageExcludedFiles.isEmpty) Seq.empty
          else Seq(s"$excludeFilePrefix:${scoverageExcludedFiles.mkString(";")}")

        val extras = excludeFiles ++ excludePkgs

        super.scalacOptions() ++ extras
      }
  }

  trait BaseTest extends SbtTests with ScoverageTests {

    protected def isScala3: Task[Boolean] = Task.Anon(JvmWorkerUtil.isScala3(outer.scalaVersion()))

    /**
     * Alter classpath from upstream modules by replacing in-place outer module
     * classes folder by the outer.scoverage classes folder and adding the
     * scoverage runtime dependency.
     */
    override def runClasspath: T[Seq[PathRef]] = Task {
      val moduleDeps = Task
        .sequence((outer.moduleDeps ++ outer.transitiveModuleDeps).map {
          case m: ScoverageModule =>
            m.compile.zip(m.scoverage.compile)
          case m: Module          =>
            m.compile.zip(m.compile)
        })()
        .map { case (m, c) => m.classes -> c.classes }
        .toMap

      val outerClassesPath          = outer.compile().classes
      val outerScoverageClassesPath = outer.scoverage.compile().classes
      (super.runClasspath().map { path =>
        if (outerClassesPath == path) outerScoverageClassesPath
        else if (moduleDeps.contains(path)) moduleDeps(path)
        else path
      } ++ defaultResolver().classpath(outer.scoverageRuntimeDeps())).distinct
    }
  }

  trait ZTests extends BaseTest with TestModule.ZioTest

  trait OrgScalaTest extends BaseTest with TestModule.ScalaTest

}

trait ScalaPBModuleSbt extends ScalaPBModule {

  def scalaPBSources: T[Seq[PathRef]] = Task.Sources(
    moduleDir / "src/main/protobuf"
  )

  def scalaPBVersion         = Versions.scalapb
  def scalaPBFlatPackage     = true
  def scalaPBJavaConversions = true
  def scalaPBGrpc            = false
  def scalaPBScala3Sources   = true
  def scalaPBSearchDeps      = true

  override def generatedSources: Task.Simple[Seq[PathRef]] = Task(super.generatedSources() :+ compileJava())

  def compileJava: T[PathRef] = Task {
    mill.api.Result.Success(PathRef(Task.dest))
  }

  override def scalaPBAdditionalArgs =
    Seq(s"--java_out=${compileJava().path}")

}

trait CommonTests extends CommonModule {
  // placeholder
}

// Core dependencies
object Dependencies {
  val all = Seq(
    mvn"org.foundationdb:fdb-java:${Versions.foundationDb}",
    mvn"dev.zio::zio:${Versions.zio}",
    mvn"dev.zio::zio-streams:${Versions.zio}",
    mvn"org.scala-lang:scala-reflect:${Versions.scala213}",
    mvn"nl.vroste::rezilience:${Versions.rezilience}",
    mvn"com.google.protobuf:protobuf-java:${Versions.protobuf}"
  )

  val test = Seq(
    mvn"dev.zio::zio-test:${Versions.zio}",
    mvn"dev.zio::zio-test-sbt:${Versions.zio}",
    mvn"dev.zio::zio-test-magnolia:${Versions.zio}"
  )

  val record = Seq(
    mvn"org.foundationdb:fdb-record-layer-core:${Versions.fdbRecord}",
    mvn"com.lihaoyi::sourcecode:${Versions.sourcecode}",
    mvn"com.thesamet.scalapb::scalapb-runtime:${Versions.scalapb}"
  )

  val recordLucene = Seq(
    mvn"org.foundationdb:fdb-record-layer-lucene:${Versions.fdbRecord}",
    mvn"org.apache.lucene:lucene-queryparser:${Versions.lucene}",
    mvn"org.apache.lucene:lucene-highlighter:${Versions.lucene}",
    mvn"com.thesamet.scalapb::scalapb-runtime:${Versions.scalapb}",
    mvn"com.google.auto.service:auto-service:${Versions.autoService}"
  )

  val pekko = Seq(
    mvn"org.apache.pekko::pekko-persistence-typed:${Versions.pekko}",
    mvn"dev.zio::zio-interop-reactivestreams:${Versions.zioReactiveStreams}"
  )

  val pekkoTest = Seq(
    mvn"org.apache.pekko::pekko-persistence-testkit:${Versions.pekko}",
    mvn"org.apache.pekko::pekko-persistence-tck:${Versions.pekko}",
    mvn"org.apache.pekko::pekko-stream-testkit:${Versions.pekko}",
    mvn"ch.qos.logback:logback-classic:${Versions.logback}"
  )

  def mkConfig(dep: Dep): Seq[Dep] = Seq(
    dep.exclude("com.google.protobuf" -> "protobuf-java"),
    dep
      .copy(dep =
        dep.dep
          .withVariantSelector(ConfigurationBased(Configuration.join(Configuration.provided, Configuration.test)))
          .withAttributes(Attributes.empty.withClassifier(Classifier("tests")))
      )
      .exclude("com.google.protobuf"  -> "protobuf-java")
  )

  def sparkAll = Seq(
    mvn"com.google.protobuf:protobuf-java-util:${Versions.protobuf}",
    mvn"com.github.plokhotnyuk.jsoniter-scala::jsoniter-scala-macros:${Versions.jsoniterScala}",
  )

  def spark(scalaVersion: String, sparkVersion: String) =
    mkConfig(mvn"org.apache.spark::spark-core:$sparkVersion".withDottyCompat(scalaVersion)) ++
      mkConfig(mvn"org.apache.spark::spark-catalyst:$sparkVersion".withDottyCompat(scalaVersion)) ++
      mkConfig(mvn"org.apache.spark::spark-sql:$sparkVersion".withDottyCompat(scalaVersion)) ++
      mkConfig(mvn"org.apache.spark::spark-protobuf:$sparkVersion".withDottyCompat(scalaVersion))

  def sparkTest(scalaVersion: String, sparkVersion: String) = {
    val note = if (sparkVersion == Versions.spark4) "4" else "3"
    Seq(
      mvn"com.goodcover.spark::spark$note-encoders:${Versions.sparkEncoders}",
      mvn"org.scalatest::scalatest:${Versions.scalatest}",
    )
  }
}

// Repository configuration
trait CustomRepositories extends SbtModule {
  def repositoriesTask = Task.Anon {
    super.repositoriesTask()
  }
}

// Core module with Protocol Buffers
object `fdb-core` extends Cross[FdbCoreModule](Versions.scalaVersions)

trait FdbCoreModule extends CommonModule {
  def mvnDeps = Dependencies.all

  def generatedSources: T[Seq[PathRef]] = Task {
    os.write(
      Task.dest / s"BuildInfo.scala",
      s"""
         |package com.goodcover.fdb
         |object BuildInfo {
         |  val scalaVersion     = "${scalaVersion()}"
         |  val fdbRecordVersion = "${Versions.fdbRecord}"
         |  val fdbVersion       = "${Versions.foundationDb}"
         |}
        """.stripMargin
    )

    Seq(PathRef(Task.dest))
  }
}

// Core tests module
object `fdb-core-tests` extends Cross[FdbCoreTestsModule](Versions.scalaVersions)

trait FdbCoreTestsModule extends CommonTests {
  def moduleDeps = Seq(`fdb-core`())
  def mvnDeps    = Dependencies.test

  object test extends ZTests
}

// Record module
object `fdb-record` extends Cross[FdbRecordModule](Versions.scalaVersions)

trait FdbRecordModule extends CommonModule with CustomRepositories {
  def moduleDeps = Seq(`fdb-core`())
  def mvnDeps    = Dependencies.record
}

// Record tests module
object `fdb-record-tests` extends Cross[FdbRecordTestsModule](Versions.scalaVersions)

trait FdbRecordTestsModule extends CommonModule {
  def moduleDeps = Seq(`fdb-record`(), `fdb-core-tests`())

  object test extends ZTests {}

}

// Record Lucene module
object `fdb-record-lucene` extends Cross[FdbRecordLuceneModule](Versions.scalaVersions)

trait FdbRecordLuceneModule extends CommonModule with CustomRepositories {
  def moduleDeps = Seq(`fdb-record`())
  def mvnDeps    = Dependencies.recordLucene
}

// Record Lucene tests module with Protocol Buffers
object `fdb-record-lucene-tests` extends Cross[FdbRecordLuceneTestsModule](Versions.scalaVersions)

trait FdbRecordLuceneTestsModule extends CommonTests with ScalaPBModuleSbt {
  def moduleDeps = Seq(`fdb-record-lucene`(), `fdb-core-tests`(), `fdb-record-tests`())
  def mvnDeps    = Dependencies.recordLucene

  object test extends ZTests {}
}

// Record ES module with Protocol Buffers
object `fdb-record-es` extends Cross[FdbRecordEsModule](Versions.scalaVersions)

trait FdbRecordEsModule extends CommonModule with ScalaPBModuleSbt {
  def moduleDeps = Seq(`fdb-record`())
  def mvnDeps    = Dependencies.record

}

// Record ES tests module
object `fdb-record-es-tests` extends Cross[FdbRecordEsTestsModule](Versions.scalaVersions)

trait FdbRecordEsTestsModule extends CommonTests {
  def moduleDeps = Seq(`fdb-record-es`(), `fdb-core-tests`(), `fdb-record-tests`())

  object test extends ZTests {}

}

// Record ES Pekko module
object `fdb-record-es-pekko` extends Cross[FdbRecordEsPekkoModule](Versions.scalaVersions)

trait FdbRecordEsPekkoModule extends CommonModule {
  def moduleDeps = Seq(`fdb-record-es`())
  def mvnDeps    = Dependencies.pekko
}

// Record ES Pekko tests module
object `fdb-record-es-pekko-tests` extends Cross[FdbRecordEsPekkoTestsModule](Versions.scalaVersions)

trait FdbRecordEsPekkoTestsModule extends CommonTests {
  def moduleDeps =
    Seq(`fdb-record-es`(), `fdb-record-es-pekko`(), `fdb-core-tests`(), `fdb-record-tests`(), `fdb-record-es-tests`())
  def mvnDeps    = Dependencies.pekko ++ Dependencies.pekkoTest

  object test extends OrgScalaTest

}

// Record ES Pekko IT module
object `fdb-record-es-pekko-it` extends Cross[FdbRecordEsPekkoItModule](Versions.scalaVersions)

trait FdbRecordEsPekkoItModule extends CommonTests {
  def moduleDeps = Seq(
    `fdb-record-es`(),
    `fdb-record-es-pekko`(),
    `fdb-core-tests`(),
    `fdb-record-tests`(),
    `fdb-record-es-tests`(),
    `fdb-record-es-pekko-tests`(),
  )

  def mvnDeps  = Dependencies.pekko
  def forkArgs = Seq("-Xmx2g")

  object test extends OrgScalaTest
}

// Spark module
object `fdb-spark` extends Cross[FdbSparkModule](Versions.sparkMatrix)

trait FdbSparkModule extends CommonModule with Cross.Module2[String, String] { outer =>
  def sparkVersion: String = crossValue2
  def moduleDeps           = Seq(`fdb-core`(), `fdb-record-es`())
  def testModuleDeps       = Seq(`fdb-core-tests`(), `fdb-record-es-tests`())
  def mvnDeps              = Dependencies.sparkAll
  def compileMvnDeps       = Dependencies.spark(scalaVersion(), sparkVersion)
  def forkArgs             = Seq("-Xmx2g")

  def artifactName = s"fdb-spark_$sparkVersion"

  // Spark tests module
  object test extends ZTests with CrossSbtTests {

    override def moduleDeps = super.moduleDeps ++ outer.testModuleDeps

    def mvnDeps =
      outer.mvnDeps() ++
        Dependencies.test ++
        Dependencies.sparkTest(scalaVersion(), outer.sparkVersion) ++
        Dependencies.spark(scalaVersion(), sparkVersion)

    def forkArgs = Task {
      val crossToken = crossValue + "-" + crossValue2
      val env        = Task.env
      val javaOpts   = env.get("JAVA_OPTS").toList.flatMap(_.split('\n')).map(_.trim).filter(_.nonEmpty)
      Seq("-Xmx2g") ++ javaOpts ++ Seq(s"-Dcross-token=$crossToken")
    }
  }

  // Spark streaming tests module, using junit
  object testStream extends OrgScalaTest with CrossSbtTests {

    def versionSourcesPaths = scalaVersionDirectoryNames.map(s => os.sub / "src/testStream" / s"scala-$s")

    override def moduleDeps = super.moduleDeps ++ Seq(test)

    def scalacOptions = super.scalacOptions() ++ (
      if (isScala3()) Seq("-Xignore-scala2-macros") else Seq.empty
    )

    def mvnDeps =
      outer.mvnDeps() ++
        Dependencies.sparkTest(scalaVersion(), outer.sparkVersion) ++
        Dependencies.spark(scalaVersion(), sparkVersion)

    def forkArgs = Task {
      val env      = Task.env
      val javaOpts = env.get("JAVA_OPTS").toList.flatMap(_.split('\n')).map(_.trim).filter(_.nonEmpty)
      Seq("-Xmx2g") ++ javaOpts
    }
  }
}

object scoverage extends ScoverageReport {
  override def scalaVersion     = Versions.scala213
  override def scoverageVersion = Versions.scoverage
}

// Version management module
object releaseProcess extends Module {

  def showState() = Task.Command {
    val log      = Task.log
    val vcsState = VcsVersion.calcVcsState(log)

    log.info("=== VCS Version Information ===")
    log.info(s" Format Version: ${vcsState.format()}")
    log.info(s" Last Tag: ${vcsState.lastTag.getOrElse("none")}")
    log.info(s" Commits Since Last Tag: ${vcsState.commitsSinceLastTag}")
    log.info(s" Current Commit: ${vcsState.currentRevision}")
    log.info(s" Dirty Changes: ${vcsState.dirtyHash.getOrElse("none")}")
  }

  def prompt(label: String): String = {
    println(label)
    System.out.flush()
    scala.io.StdIn.readLine()
  }

  /**
   * Interactive version release command that:
   *   1. Gets current version from VCS
   *   2. Proposes incrementing the patch version
   *   3. Allows you to input a custom version
   *   4. Creates and pushes a git tag
   *   5. Creates an empty commit with version increment message
   *   6. Pushes the tag and current branch
   */
  def release() = Task.Command {
    import mill.util.VcsVersion
    import scala.io.AnsiColor._

    val log       = Task.log
    val workspace = Task.ctx().workspace

    // Get current VCS state
    val vcsState = VcsVersion.calcVcsState(log)
    showState()

    // Parse current version and propose patch increment
    val currentVersion  = vcsState.lastTag.getOrElse("0.0.0")
    val proposedVersion = "v" + incrementPatchVersion(currentVersion)

    log.info("")
    log.info(s"  Current version: $BOLD$currentVersion$RESET")
    log.info(s" Proposed version: $BOLD$proposedVersion$RESET")
    log.info("")

    // Check for uncommitted changes
//    if (vcsState.dirtyHash.isDefined) {
//      log.error("ERROR: You have uncommitted changes. Please commit or stash them before releasing.")
//      throw new Exception("Uncommitted changes detected")
//    }

    // Interactive prompt for version
    val input      = prompt(s"Enter new version (press Enter for $BOLD$proposedVersion$RESET): ")
    val newVersion = if (input == null) {
      log.error("==============================================")
      log.error("ERROR: Got a null, this is likely due to not running ./mill -i --ticker=false ...")
      log.error("Please retry with ./mill -i --ticker=false ...")
      log.error("==============================================")
      Task.fail(s"re-run with ./mill -i --ticker=false ...")
    } else if (input.isEmpty) proposedVersion
    else input

    // Validate version format
    if (!isValidVersion(newVersion)) {
      log.error(s"ERROR: Invalid version format: $newVersion")
      log.error("Version should be in format: vX.Y.Z or vX.Y.Z-suffix")
      Task.fail("Invalid version format")
    }

    // Get current branch
    val currentBranch = os
      .proc("git", "rev-parse", "--abbrev-ref", "HEAD")
      .call(cwd = workspace)
      .out
      .text()
      .trim

    log.info("")
    log.info(s" Releasing version: $BOLD$newVersion$RESET")
    log.info(s"    Current branch: $BOLD$currentBranch$RESET")
    log.info("")

    // Confirm
    log.info("")
    val confirm =
      prompt(s"Are you sure you want to release version $BOLD$newVersion$RESET on branch $BOLD$currentBranch$RESET? (y/N): ")

    if (confirm != "y" && confirm != "yes") {
      log.info("Release cancelled.")
      Task.fail("Release cancelled")
    }

    try {
      // Step 1: Create and push the tag
      log.info(s"Creating tag: $newVersion")
//      os.proc("git", "tag", "-a", newVersion, "-m", s"Release $newVersion")
//        .call(cwd = workspace, stdout = os.Inherit)

      log.info(s"Pushing tag: $newVersion")
//      os.proc("git", "push", "origin", newVersion)
//        .call(cwd = workspace, stdout = os.Inherit)

      // Step 2: Create empty commit with version increment message
      log.info("Creating version increment commit")
//      os.proc("git", "commit", "--allow-empty", "-m", s"Increment version to $newVersion")
//        .call(cwd = workspace, stdout = os.Inherit)

      // Step 3: Push current branch
      log.info(s"Pushing branch: $currentBranch")
//      os.proc("git", "push", "origin", currentBranch)
//        .call(cwd = workspace, stdout = os.Inherit)

      log.info("")
      log.info(s"✓ Successfully released version $newVersion")
      log.info(s"✓ Tag $newVersion created and pushed")
      log.info(s"✓ Branch $currentBranch pushed")

    } catch {
      case e: Exception =>
        log.error(s"ERROR during release: ${e.getMessage}")
        log.error("You may need to manually clean up git state")
        throw e
    }
  }

  /** Increment the patch version of a semantic version string */
  private def incrementPatchVersion(version: String): String = {
    // Remove 'v' prefix if present
    val cleanVersion = if (version.startsWith("v")) version.substring(1) else version

    // Split on '-' to handle versions like "1.2.3-SNAPSHOT"
    val parts       = cleanVersion.split("-", 2)
    val versionPart = parts(0)
    val suffix      = if (parts.length > 1) Some(parts(1)) else None

    // Split version into major.minor.patch
    val versionNumbers = versionPart.split("\\.").map(_.toIntOption.getOrElse(0))

    val (major, minor, patch) = versionNumbers.length match {
      case 0 => (0, 0, 1)
      case 1 => (versionNumbers(0), 0, 1)
      case 2 => (versionNumbers(0), versionNumbers(1), 1)
      case _ => (versionNumbers(0), versionNumbers(1), versionNumbers(2) + 1)
    }

    val newVersion = s"$major.$minor.$patch"
    suffix.map(s => s"$newVersion-$s").getOrElse(newVersion)
  }

  /** Validate version format (basic semantic versioning) */
  private def isValidVersion(version: String): Boolean = {
    val semverPattern = """^v\d+\.\d+\.\d+(-[\w\.\-]+)?$""".r
    semverPattern.matches(version)
  }

  /** Show current version information */
  def show() = Task.Command {
    import mill.util.VcsVersion

    val log      = Task.log
    val vcsState = VcsVersion.calcVcsState(log)
    showState()

    val currentVersion  = vcsState.lastTag.getOrElse("0.0.0")
    val proposedVersion = incrementPatchVersion(currentVersion)
    log.info("")
    log.info(s" Current Version: $currentVersion")
    log.info(s" Next Patch Version: $proposedVersion")
  }
}
